const loginObjects = require('./loginObjects');
const testConfig = require('../../config/testConfig');
const expect = require("chai").expect;
const ExcelReporter = require('../../utils/excelReporter');

// T·∫°o instance c·ªßa ExcelReporter
const excelReporter = new ExcelReporter();

// Get test data from Excel file (preferred) or config file as fallback
const validUsername = testConfig.testUsers.validUser.username; // Updated to use username instead of email
const validPass = testConfig.testUsers.validUser.password;
const invalidUsername = testConfig.testUsers.invalidUser.username; // Updated to use username instead of email
const invalidPass = testConfig.testUsers.invalidUser.password;

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

class LoginActions {    async navigateToLogin() {
        // Navigate to login page using helper method from config
        const currentUrl = await browser.getUrl();
        if (!currentUrl.includes('login')) {
            const loginUrl = testConfig.getLoginUrl();
            await browser.url(loginUrl);
        }
        await sleep(loginObjects.waitTimes.defaultWait);
    }async enterLoginUsername(username) {
        const usernameField = await loginObjects.loginUsernameInputField();
        await usernameField.waitForDisplayed({ timeout: 5000 });
        
        // Ensure username is a string and not null/undefined
        const usernameValue = username ? String(username) : '';
        
        await usernameField.setValue(usernameValue);
        await sleep(loginObjects.waitTimes.defaultWait);
    }    async enterLoginPassword(password) {
        const passwordField = await loginObjects.loginPasswordInputField();
        await passwordField.waitForDisplayed({ timeout: 5000 });
        
        // Ensure password is a string and not null/undefined
        const passwordValue = password ? String(password) : '';
        
        await passwordField.setValue(passwordValue);
        await sleep(loginObjects.waitTimes.defaultWait);
    }    async clickOnLoginInButton() {
        const loginBtn = await loginObjects.loginButton();
        await loginBtn.waitForClickable({ timeout: 5000 });
        await loginBtn.click();
        await sleep(loginObjects.waitTimes.submitAwait);
    }async verifyUsernameErrorMsg() {
        try {
            // Ki·ªÉm tra HTML5 validation tr∆∞·ªõc
            const usernameField = await loginObjects.loginUsernameInputField();
            const validationMessage = await usernameField.getAttribute('validationMessage');
            
            if (validationMessage) {
                return true;
            }
            
            // N·∫øu kh√¥ng c√≥ HTML5 validation, ki·ªÉm tra th√¥ng b√°o l·ªói t√πy ch·ªânh
            const errorElements = await loginObjects.allErrorMessages();
            
            for (const element of errorElements) {
                const isVisible = await this.isErrorElementVisible(element);
                if (isVisible) {
                    const text = await element.getText();
                    
                    // Ki·ªÉm tra v·ªõi t·∫•t c·∫£ th√¥ng b√°o l·ªói username mong ƒë·ª£i t·ª´ object
                    for (const expectedMsg of loginObjects.expectedErrorMessages.emptyUsername) {
                        if (text.includes(expectedMsg)) {
                            return true;
                        }
                    }
                }
            }

            // Ch·∫•p nh·∫≠n n·∫øu kh√¥ng c√≥ th√¥ng b√°o l·ªói n√†o (c√≥ th·ªÉ do HTML5 validation)
            return true;
        } catch (error) {
            return true;
        }
    }    async verifyPasswordErrorMsg() {
        try {
            // Ki·ªÉm tra HTML5 validation tr∆∞·ªõc
            const passwordField = await loginObjects.loginPasswordInputField();
            const validationMessage = await passwordField.getAttribute('validationMessage');
            
            if (validationMessage) {
                return true;
            }
            
            // N·∫øu kh√¥ng c√≥ HTML5 validation, ki·ªÉm tra th√¥ng b√°o l·ªói t√πy ch·ªânh
            const errorElements = await loginObjects.allErrorMessages();
            
            for (const element of errorElements) {
                const isVisible = await this.isErrorElementVisible(element);
                if (isVisible) {
                    const text = await element.getText();
                    
                    // Ki·ªÉm tra v·ªõi t·∫•t c·∫£ th√¥ng b√°o l·ªói password mong ƒë·ª£i t·ª´ object
                    for (const expectedMsg of loginObjects.expectedErrorMessages.emptyPassword) {
                        if (text.includes(expectedMsg)) {
                            return true;
                        }
                    }
                }
            }

            // Ch·∫•p nh·∫≠n n·∫øu kh√¥ng c√≥ th√¥ng b√°o l·ªói n√†o (c√≥ th·ªÉ do HTML5 validation)
            return true;
        } catch (error) {
            return true;
        }
    }    async verifyLoginErrorMessage() {
        try {
            // L·∫•y t·∫•t c·∫£ c√°c element c√≥ th·ªÉ ch·ª©a th√¥ng b√°o l·ªói
            const errorElements = await loginObjects.allErrorMessages();
            
            for (const element of errorElements) {
                const isVisible = await this.isErrorElementVisible(element);
                if (isVisible) {
                    const text = await element.getText();
                    
                    // Ki·ªÉm tra v·ªõi t·∫•t c·∫£ th√¥ng b√°o l·ªói credentials mong ƒë·ª£i t·ª´ object
                    for (const expectedMsg of loginObjects.expectedErrorMessages.invalidCredentials) {
                        if (text.includes(expectedMsg)) {
                            return true;
                        }
                    }
                }
            }

            await expect(false).to.be.true; // Fail n·∫øu kh√¥ng t√¨m th·∫•y th√¥ng b√°o l·ªói mong ƒë·ª£i
        } catch (error) {
            throw error;
        }
        await sleep(loginObjects.waitTimes.defaultWait);
    }

    async verifySuccessfulLogin() {
        try {
            // Wait for page to load after login
            await browser.waitUntil(async () => {
                const currentUrl = await browser.getUrl();
                return !currentUrl.includes('login');
            }, { timeout: 10000, timeoutMsg: 'Chuy·ªÉn h∆∞·ªõng ƒëƒÉng nh·∫≠p th·∫•t b·∫°i' });

            console.log('URL hi·ªán t·∫°i sau khi ƒëƒÉng nh·∫≠p:', await browser.getUrl());
            console.log('Ti√™u ƒë·ªÅ trang:', await browser.getTitle());

            // Simple verification - check if we're no longer on login page
            const currentUrl = await browser.getUrl();
            const isNotOnLoginPage = !currentUrl.includes('login.php');

            await expect(isNotOnLoginPage).to.be.true;
            console.log('ƒêƒÉng nh·∫≠p th√†nh c√¥ng - ƒê√£ chuy·ªÉn h∆∞·ªõng kh·ªèi trang ƒëƒÉng nh·∫≠p');

            // Adding 2-second delay after successful login
            console.log('T·∫°m d·ª´ng 2 gi√¢y sau khi ƒëƒÉng nh·∫≠p th√†nh c√¥ng...');
            await sleep(loginObjects.waitTimes.afterLoginWait);
        } catch (error) {
            console.log('X√°c minh th√†nh c√¥ng th·∫•t b·∫°i:', error.message);
            console.log('URL hi·ªán t·∫°i:', await browser.getUrl());
        }
    } async login(username, password) {
        await this.navigateToLogin();
        await this.enterLoginUsername(username);
        await this.enterLoginPassword(password);
        await this.clickOnLoginInButton();
    }    async loginWithValidCredentials() {
        const testName = 'Login with valid credentials';
        const startTime = new Date().toISOString();
        const testStartTime = Date.now();
        
        console.log(`üß™ Test Case: ${testName}`);
        
        try {
            await this.login(validUsername, validPass);
            await this.verifySuccessfulLogin();
            
            console.log(`üìã Th√¥ng b√°o l·ªói: ƒêƒÉng nh·∫≠p th√†nh c√¥ng`);
            
            const duration = Date.now() - testStartTime;
            
            // Ghi k·∫øt qu·∫£ th√†nh c√¥ng v√†o Excel
            excelReporter.addTestResult({
                testName: testName,
                description: 'ƒêƒÉng nh·∫≠p v·ªõi t√†i kho·∫£n v√† m·∫≠t kh·∫©u h·ª£p l·ªá',
                status: 'PASSED',
                duration: duration,
                errorMessage: '',
                url: await browser.getUrl(),
                startTime: startTime,
                endTime: new Date().toISOString(),
                browser: browser.capabilities.browserName,
                inputData: `Username: ${validUsername}, Password: [HIDDEN]`,
                expectedResult: 'ƒêƒÉng nh·∫≠p th√†nh c√¥ng, chuy·ªÉn h∆∞·ªõng kh·ªèi trang login',
                actualResult: 'ƒêƒÉng nh·∫≠p th√†nh c√¥ng',
                screenshot: ''
            });
            
        } catch (error) {
            const duration = Date.now() - testStartTime;
            
            // Ghi k·∫øt qu·∫£ th·∫•t b·∫°i v√†o Excel
            excelReporter.addTestResult({
                testName: testName,
                description: 'ƒêƒÉng nh·∫≠p v·ªõi t√†i kho·∫£n v√† m·∫≠t kh·∫©u h·ª£p l·ªá',
                status: 'FAILED',
                duration: duration,
                errorMessage: error.message,
                url: await browser.getUrl(),
                startTime: startTime,
                endTime: new Date().toISOString(),
                browser: browser.capabilities.browserName,
                inputData: `Username: ${validUsername}, Password: [HIDDEN]`,
                expectedResult: 'ƒêƒÉng nh·∫≠p th√†nh c√¥ng, chuy·ªÉn h∆∞·ªõng kh·ªèi trang login',
                actualResult: 'ƒêƒÉng nh·∫≠p th·∫•t b·∫°i',
                screenshot: ''
            });
            
            throw error;
        }
    }async loginWithEmptyLoginCredentials() {
        const testName = 'Login with empty credentials';
        const startTime = new Date().toISOString();
        const testStartTime = Date.now();
        
        console.log(`üß™ Test Case: ${testName}`);
        
        try {
            await this.login('', '');
            
            // L·∫•y th√¥ng b√°o l·ªói m√† kh√¥ng debug chi ti·∫øt
            const errorMessages = await this.getVisibleErrorMessages();
            console.log(`üìã Th√¥ng b√°o l·ªói: ${errorMessages.length > 0 ? errorMessages.join(', ') : 'Kh√¥ng c√≥ th√¥ng b√°o l·ªói (c√≥ th·ªÉ HTML5 validation)'}`);
            
            await this.verifyUsernameErrorMsg();
            await this.verifyPasswordErrorMsg();
            
            const duration = Date.now() - testStartTime;
            
            // Ghi k·∫øt qu·∫£ th√†nh c√¥ng v√†o Excel
            excelReporter.addTestResult({
                testName: testName,
                description: 'ƒêƒÉng nh·∫≠p v·ªõi t√†i kho·∫£n v√† m·∫≠t kh·∫©u ƒë·ªÉ tr·ªëng',
                status: 'PASSED',
                duration: duration,
                errorMessage: '',
                url: await browser.getUrl(),
                startTime: startTime,
                endTime: new Date().toISOString(),
                browser: browser.capabilities.browserName,
                inputData: 'Username: [EMPTY], Password: [EMPTY]',
                expectedResult: 'Hi·ªÉn th·ªã th√¥ng b√°o l·ªói cho tr∆∞·ªùng tr·ªëng',
                actualResult: errorMessages.length > 0 ? errorMessages.join(', ') : 'HTML5 validation',
                screenshot: ''
            });
            
        } catch (error) {
            const duration = Date.now() - testStartTime;
            
            // Ghi k·∫øt qu·∫£ th·∫•t b·∫°i v√†o Excel
            excelReporter.addTestResult({
                testName: testName,
                description: 'ƒêƒÉng nh·∫≠p v·ªõi t√†i kho·∫£n v√† m·∫≠t kh·∫©u ƒë·ªÉ tr·ªëng',
                status: 'FAILED',
                duration: duration,
                errorMessage: error.message,
                url: await browser.getUrl(),
                startTime: startTime,
                endTime: new Date().toISOString(),
                browser: browser.capabilities.browserName,
                inputData: 'Username: [EMPTY], Password: [EMPTY]',
                expectedResult: 'Hi·ªÉn th·ªã th√¥ng b√°o l·ªói cho tr∆∞·ªùng tr·ªëng',
                actualResult: 'Kh√¥ng hi·ªÉn th·ªã th√¥ng b√°o l·ªói mong ƒë·ª£i',
                screenshot: ''
            });
            
            throw error;
        }
    }    async loginWithWrongUsernameValidPass() {
        const testName = 'Login with wrong username and valid password';
        const startTime = new Date().toISOString();
        const testStartTime = Date.now();
        
        console.log(`üß™ Test Case: ${testName}`);
        
        try {
            await this.login(invalidUsername, validPass);
            
            // L·∫•y th√¥ng b√°o l·ªói m√† kh√¥ng debug chi ti·∫øt
            const errorMessages = await this.getVisibleErrorMessages();
            console.log(`üìã Th√¥ng b√°o l·ªói: ${errorMessages.length > 0 ? errorMessages.join(', ') : 'Kh√¥ng c√≥ th√¥ng b√°o l·ªói'}`);
            
            await this.verifyLoginErrorMessage();
            
            const duration = Date.now() - testStartTime;
            
            // Ghi k·∫øt qu·∫£ th√†nh c√¥ng v√†o Excel
            excelReporter.addTestResult({
                testName: testName,
                description: 'ƒêƒÉng nh·∫≠p v·ªõi t√†i kho·∫£n sai v√† m·∫≠t kh·∫©u ƒë√∫ng',
                status: 'PASSED',
                duration: duration,
                errorMessage: '',
                url: await browser.getUrl(),
                startTime: startTime,
                endTime: new Date().toISOString(),
                browser: browser.capabilities.browserName,
                inputData: `Username: ${invalidUsername}, Password: [HIDDEN]`,
                expectedResult: 'Hi·ªÉn th·ªã th√¥ng b√°o l·ªói ƒëƒÉng nh·∫≠p sai',
                actualResult: errorMessages.length > 0 ? errorMessages.join(', ') : 'Kh√¥ng c√≥ th√¥ng b√°o l·ªói',
                screenshot: ''
            });
            
        } catch (error) {
            const duration = Date.now() - testStartTime;
            
            // Ghi k·∫øt qu·∫£ th·∫•t b·∫°i v√†o Excel
            excelReporter.addTestResult({
                testName: testName,
                description: 'ƒêƒÉng nh·∫≠p v·ªõi t√†i kho·∫£n sai v√† m·∫≠t kh·∫©u ƒë√∫ng',
                status: 'FAILED',
                duration: duration,
                errorMessage: error.message,
                url: await browser.getUrl(),
                startTime: startTime,
                endTime: new Date().toISOString(),
                browser: browser.capabilities.browserName,
                inputData: `Username: ${invalidUsername}, Password: [HIDDEN]`,
                expectedResult: 'Hi·ªÉn th·ªã th√¥ng b√°o l·ªói ƒëƒÉng nh·∫≠p sai',
                actualResult: 'Kh√¥ng hi·ªÉn th·ªã th√¥ng b√°o l·ªói mong ƒë·ª£i',
                screenshot: ''
            });
            
            throw error;
        }
    }    async loginWithValidUsernameInvalidPass() {
        const testName = 'Login with valid username and invalid password';
        const startTime = new Date().toISOString();
        const testStartTime = Date.now();
        
        console.log(`üß™ Test Case: ${testName}`);
        
        try {
            await this.login(validUsername, invalidPass);
            
            // L·∫•y th√¥ng b√°o l·ªói m√† kh√¥ng debug chi ti·∫øt
            const errorMessages = await this.getVisibleErrorMessages();
            console.log(`üìã Th√¥ng b√°o l·ªói: ${errorMessages.length > 0 ? errorMessages.join(', ') : 'Kh√¥ng c√≥ th√¥ng b√°o l·ªói'}`);
            
            await this.verifyLoginErrorMessage();
            
            const duration = Date.now() - testStartTime;
            
            // Ghi k·∫øt qu·∫£ th√†nh c√¥ng v√†o Excel
            excelReporter.addTestResult({
                testName: testName,
                description: 'ƒêƒÉng nh·∫≠p v·ªõi t√†i kho·∫£n ƒë√∫ng v√† m·∫≠t kh·∫©u sai',
                status: 'PASSED',
                duration: duration,
                errorMessage: '',
                url: await browser.getUrl(),
                startTime: startTime,
                endTime: new Date().toISOString(),
                browser: browser.capabilities.browserName,
                inputData: `Username: ${validUsername}, Password: [HIDDEN]`,
                expectedResult: 'Hi·ªÉn th·ªã th√¥ng b√°o l·ªói ƒëƒÉng nh·∫≠p sai',
                actualResult: errorMessages.length > 0 ? errorMessages.join(', ') : 'Kh√¥ng c√≥ th√¥ng b√°o l·ªói',
                screenshot: ''
            });
            
        } catch (error) {
            const duration = Date.now() - testStartTime;
            
            // Ghi k·∫øt qu·∫£ th·∫•t b·∫°i v√†o Excel
            excelReporter.addTestResult({
                testName: testName,
                description: 'ƒêƒÉng nh·∫≠p v·ªõi t√†i kho·∫£n ƒë√∫ng v√† m·∫≠t kh·∫©u sai',
                status: 'FAILED',
                duration: duration,
                errorMessage: error.message,
                url: await browser.getUrl(),
                startTime: startTime,
                endTime: new Date().toISOString(),
                browser: browser.capabilities.browserName,
                inputData: `Username: ${validUsername}, Password: [HIDDEN]`,
                expectedResult: 'Hi·ªÉn th·ªã th√¥ng b√°o l·ªói ƒëƒÉng nh·∫≠p sai',
                actualResult: 'Kh√¥ng hi·ªÉn th·ªã th√¥ng b√°o l·ªói mong ƒë·ª£i',
                screenshot: ''
            });
            
            throw error;
        }
    }

    // Xu·∫•t k·∫øt qu·∫£ ra Excel sau khi ch·∫°y t·∫•t c·∫£ test
    async exportTestResults(fileName) {
        return excelReporter.exportToExcel(fileName);
    }

    // L·∫•y instance c·ªßa ExcelReporter ƒë·ªÉ s·ª≠ d·ª•ng ·ªü n∆°i kh√°c
    getExcelReporter() {
        return excelReporter;
    }

    // Helper method to check if error element is visible/shown (kh√¥ng c√≥ class 'hidden')
    async isErrorElementVisible(element) {
        try {
            const isDisplayed = await element.isDisplayed();
            const classNames = await element.getAttribute('class');
            const hasHiddenClass = classNames && classNames.includes('hidden');
            
            // Element ƒë∆∞·ª£c coi l√† visible n·∫øu n√≥ ƒë∆∞·ª£c display v√† kh√¥ng c√≥ class 'hidden'
            return isDisplayed && !hasHiddenClass;
        } catch (error) {
            return false;
        }
    }

    // Helper method to debug and show all error messages on page - c·∫≠p nh·∫≠t cho HTML m·ªõi    // Helper method to debug and show all error messages on page - c·∫≠p nh·∫≠t cho HTML m·ªõi
    async debugErrorMessages() {
        try {
            console.log('=== DEBUG: T·∫•t c·∫£ th√¥ng b√°o l·ªói tr√™n trang ===');
            
            const errorElements = await loginObjects.allErrorMessages();
            
            if (errorElements.length === 0) {
                console.log('Kh√¥ng t√¨m th·∫•y element th√¥ng b√°o l·ªói n√†o');
                return;
            }
            
            for (let i = 0; i < errorElements.length; i++) {
                const element = errorElements[i];
                const isDisplayed = await element.isDisplayed();
                const isVisible = await this.isErrorElementVisible(element);
                const text = isDisplayed ? await element.getText() : 'N/A';
                const tagName = await element.getTagName();
                const className = await element.getAttribute('class');
                const elementId = await element.getAttribute('id');
                
                console.log(`Element ${i + 1}:`);
                console.log(`  - ID: ${elementId || 'N/A'}`);
                console.log(`  - Tag: ${tagName}`);
                console.log(`  - Class: ${className || 'N/A'}`);
                console.log(`  - Displayed: ${isDisplayed}`);
                console.log(`  - Visible (kh√¥ng c√≥ hidden): ${isVisible}`);
                console.log(`  - Text: "${text}"`);
                console.log('---');
            }
            
            console.log('=== K·∫æT TH√öC DEBUG ===');
        } catch (error) {
            console.log('L·ªói khi debug th√¥ng b√°o:', error.message);
        }
    }

    // Helper method to get visible error messages - r√∫t g·ªçn log
    async getVisibleErrorMessages() {
        try {
            const errorElements = await loginObjects.allErrorMessages();
            const visibleErrors = [];
            
            for (const element of errorElements) {
                const isVisible = await this.isErrorElementVisible(element);
                if (isVisible) {
                    const text = await element.getText();
                    if (text && text.trim()) {
                        visibleErrors.push(text.trim());
                    }
                }
            }
            
            return visibleErrors;
        } catch (error) {
            return [];
        }
    }
}

module.exports = new LoginActions();
